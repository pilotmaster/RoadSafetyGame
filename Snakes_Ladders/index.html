<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1 minimum-scale=1
			user-scalable=no">
			
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="mobile-web-app-capable" content="yes">
		
		<title>Snakes & Ladders: Road Safety</title>
			
		<!-- Run the script which loads all of the sprites from the sprite sheet -->
		<script src="SpritesList.js"></script>
		<script src="Utilities.js"></script>

		<style>
		body
		{ 
			margin:10px;
		}
		
		#my_canvas
		{ 
			box-shadow: 0px 0px 0px 6px #ff0000;
			border: 8px solid #f;
			margin: 0 auto;			
		}
		</style>
	</head>
	<body>
	
	<canvas id="my_canvas"></canvas>
	
		<script>
		
		<!-- JavaScript section -->
		<!-- VARIABLES -->
		var

		<!-- Window-based data -->
		canvas,
		context,
		width,
		height,
		elemLeft,
		elemTop,
		
		<!-- Run-time game data -->
		frames = 0,
		curPlayer = 0,
		numPlayers = 1,
		playersList,
		buttonsAmount = 2,
		buttonsArray = new Array(buttonsAmount),
		
		frameTime,
		timeNow,
		timeBefore = new Date().getTime(),

		<!-- Game state data -->
		curState,
		EStates =
		{
			SPLASH: 0, GAME: 1, MESSAGE: 2, WINNER: 3
		},
		
		ETurnPhase =
		{
			WAITING: 0, ROLLING_DICE: 1, MOVING: 2, REACT_TO_TILE: 3, NEXT_PLAYER: 4
		},
		curTurnPhase = ETurnPhase.WAITING;
		//ssdsd sd
			
		<!-- FUNCTIONS -->
		function Main()
		{
			curState = EStates.SPLASH;
			<!-- Create the canvas -->
			canvas = document.getElementById("my_canvas");

			<!-- Set the canvas width and height, along with the type of border. Update the context and apply changes -->
			width = window.innerWidth;
			height = window.innerHeight;
			canvas.width = width;
			canvas.height = height;
			//canvas.style.border = "1px solid #000";
			context = canvas.getContext("2d");
			
			// Set the background colour
			context.fillStyle = "#000000";			
			
			// Event handler
			elemLeft = canvas.offsetLeft;
			elemTop  = canvas.offsetTop;
			
			document.body.appendChild(canvas);
			
			// Load the main menu sprites
			LoadMenuSprites();
			
			// Event Listener for mouse clicks
			canvas.addEventListener("click", function() 
			{
				mouseX = event.pageX - elemLeft;
				mouseY = event.pageY - elemTop;

				for (i = 0; i < buttonsAmount; i++)
				{
					buttonsArray[i].BeenClicked();
				}
			}, false);
			
			// array for buttons 
			buttonsArray[0] = new Button(rollDiceButton, EbuttonType.RollDice);
			buttonsArray[1] = new Button(playButton, EbuttonType.StartGame);
			
			Run();
		}
		
		function Run()
		{
			<!-- Create a loop to go through updating the entities and then rendering them -->
			var loop = function()
			{
				Update();
				Render();
				window.requestAnimationFrame(loop, canvas);
			}
			window.requestAnimationFrame(loop, canvas);
		}
		
		function Update()
		{
			// Get the frame time
			timeNow = new Date().getTime();
			frameTime = timeNow - timeBefore;
			timeBefore = timeNow;
			
			// Increment the number of frames passed
			frames++;
			
			// Validate the current game state
			if (curState == EStates.GAME)
			{
				// TESTING LERP FUNCTION
				//testImage.mDrawPosX = LerpToVal(testImage.mDrawPosX, 600, frameTime * 0.005);
			
				// Check if it is in the rolling dice phase
				if (curTurnPhase == ETurnPhase.ROLLING_DICE && frames % 8 == 0)
				{
					// Check if it has 0 rolls left
					if (diceRolls <= 0)
					{
						// It has finished rolling the dice - move to next phase
						curTurnPhase = ETurnPhase.MOVING;
					}
					else
					{
						// Decrease number of rolls left to do
						diceRolls = diceRolls - 1;
						
						// Get a new random dice number
						diceNum = Math.floor((Math.random() * 6));
						amountToMove = 99;//diceNum + 1;
					}
				}
				else if (curTurnPhase == ETurnPhase.MOVING)
				{
					// Check the amount left to move
					if (amountToMove > 0)
					{
						// Move the current player
						playersList[curPlayer].Move();
					}
					else
					{
						// Set to the next phase
						curTurnPhase = ETurnPhase.REACT_TO_TILE;
					}
				}
				else if (curTurnPhase == ETurnPhase.REACT_TO_TILE)
				{
					// Check if the tile the player has landed on contains an alternate location
					var curGridTile = boardArray.mBoardArray[playersList[curPlayer].mPlayerGridPos];
					if (curGridTile.mHasAlternateDestination)
					{
						// Has an alternate destination - display a message
						
						// Move the player to the other location
						playersList[curPlayer].mTargetGridPos = curGridTile.mAltDestinationIndex;
						
						// Set move amount to 1 and also change state to MOVING
						amountToMove = 1;
						curTurnPhase = ETurnPhase.MOVING;
					}
					else
					{
						// Go to the next player
						curTurnPhase = ETurnPhase.NEXT_PLAYER;
					}
				
					// TO DO: just move to next player
					//curTurnPhase = ETurnPhase.NEXT_PLAYER;
				}
				else if (curTurnPhase == ETurnPhase.NEXT_PLAYER)
				{
					// Increment to the next player
					curPlayer += 1;
					
					// Check if it should loop back round to player 1
					if (curPlayer == numPlayers)
					{
						curPlayer = 0;
					}
					
					// Set the state to waiting
					curTurnPhase = ETurnPhase.WAITING;
				}
			}
		}
		
		function Render()
		{
			// Render the background again
			context.fillRect(0, 0, width, height);
			
			// if the game is in the menu state
			if(curState == EStates.SPLASH)
			{
				title.Draw(context, title.mWidth,  title.mHeight);
				playButton.Draw(context, title.mWidth, title.mHeight);
			}
			
			// if the game is in the play state 
			if(curState == EStates.GAME)
			{
				// Order of drawing is important. Anything new drawn replaces anything old drawn
				// Start by drawing the board of the game
				spriteBoard.Draw(context, spriteBoard.mWidth, spriteBoard.mHeight);
				
				// Only draw the dice button when in the waiting phase
				if (curTurnPhase == ETurnPhase.WAITING)
				{
					rollDiceButton.Draw(context, rollDiceButton.mWidth, rollDiceButton.mHeight);
				}
				
				// Draw the current dice number
				spriteDice[diceNum].Draw(context, spriteDice[diceNum].mWidth, spriteDice[diceNum].mHeight);
				
				// Render each player
				for (i = 0; i < numPlayers; i++)
				{
					// Call the render function for the given player - as long as it is not the current player
					if (i != curPlayer)
					{
						playersList[i].Render(context);
					}
				}
				
				// Draw the glow and sprite for the current player
				// Current player drawn last so it appears above all other players
				playersList[curPlayer].mPiece.DrawGlow();
				playersList[curPlayer].Render(context);
			}
		}
		
		<!-- Start execution by calling the Main function -->
		Main();
		
		</script>
	</body>
</html>